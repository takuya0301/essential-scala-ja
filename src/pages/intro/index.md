# 式・型・値

本章では Scala プログラムの基本的な構成要素である*式*・*型*・*値*について見ていきます。それらのコンセプトを理解することが Scala プログラムがどのように動くのかというメンタルモデルを形成するために必要です。

## 最初のプログラム

Scala コンソールか Scala ワークシートに `"Hello world!"` と入力し、コンソールでリターンキーを押下するかワークシートを保存してください。このようなインタラクションが見られるはずです。

```tut:book
"Hello world!"
```

このプログラムについてはいろいろ言えることがあります。それは特別に*リテラル式*もしくは略してリテラルと呼ばれる単一の式で構成されていることです。

Scala は私たちのプログラムを実行（評価）します。Scala コンソールや Scala ワークシートでプログラムを評価するとき、プログラムの*型*とプログラムを評価した*値*という2つの情報を受け取ります。この場合は、型が `String` で、値が `"Hello world!"` です。

プログラムが生成した出力値 "Hello world!" はプログラムと同じに見えますが、その2つの間には違いがあります。リテラル式は入力したプログラムテキストである一方、コンソールが表示したものはプログラムを評価した結果です。（リテラル (literal) は、評価されたものがその文字通り (literally) に見えるので名付けられました。）

わずかに複雑なプログラムを見てみましょう。

```tut:book
"Hello world!".toUpperCase
```

このプログラムは*メソッド呼び出し*を加えることによって最初の例を拡張したものです。Scala における評価は左から右へ進みます。この例では、最初にリテラル `"Hello world!"` が評価されます。次に、その評価された結果に対しメソッド `toUpperCase` が呼ばれます。このメソッドは文字列値を大文字に変換したものを新しい文字列として返します。これがコンソールによって表示された最終的な値です。

繰り返しになりますが、このプログラムの型は `String` で、この場合はプログラムが `"HELLO WORLD!"` に評価されます。

### コンパイル時と実行時

Scala プログラムが通過する明確な2つの段階があります。最初が*コンパイル*で、コンパイルが成功していれば、次が*実行*（評価）です。最初のステージを*コンパイル時*、次のステージを*実行時*と呼びます。

Scala コンソールを使用しているとき、プログラムはコンパイルしてすぐに評価されるので、1つの段階だけがあるような印象を抱かせます。型と値の間における違いを正しく理解するためにも、コンパイル時と実行時がまったく異なることを理解するのは重要です。

コンパイルはプログラムが意味をなしているかを検証する工程です。プログラムが「意味をなす」には2つの観点が必要です。

1. プログラムは*文法的に正確*でなければなりません。それはプログラムの部品が言語の文法に従っているということを意味します。"on cat mat sat the"（猫の上敷き物座った）は文法的に正確ではない英文の例です。これは文法的に正確ではない Scala プログラムの例です。

```tut:book:fail
toUpperCase."Hello world!"
```

2. プログラムは*型検証*されなければなりません。意味をなすプログラムであるということは、プログラムがある制約に従っているということを意味します。"the mat sat on the cat"（敷き物は猫の上に座った）は文法的に正確ですが意味がわからない英文の例です。これは数値を大文字に変換しようとして型検証に失敗するシンプルなプログラムです。

```tut:book:fail
2.toUpperCase
```

大文字小文字という概念は数値について意味をなさないので、型システムはこのエラーを捕捉します。

プログラムがコンパイル時の検証を通過した場合、次にプログラムは実行されるかもしれません。実行はコンピューターがプログラムにある指示を実行する工程です。

プログラムのコンパイルが成功したとしても、実行時に失敗する可能性が残っています。整数を0で割ると Scala では実行時エラーが発生します。

```tut:book:fail
2 / 0
```

整数の型 `Int` はプログラムの型検証を通過すれば割り算できます。しかし、割り算の結果を表現できる `Int` が存在しないので、実行時にプログラムは失敗します。


### 式・型・値

それでは、式・型・値とは正確には何でしょうか？

式はファイルやコンソール、ワークシートに入力したプログラムテキストの一部です。それは Scala プログラムの主要な構成要素です。のちほど、*定義*や*文*と名付けられた他の構成要素も見ていきます。式はコンパイル時に存在します。

式の特徴を定義すると、それは値に評価されるということです。値はコンピューターのメモリに保持されます。それは実行時に存在します。例えば、式 `2` は、コンピューターのメモリの、特定の場所の、特定のビット列に評価されます。

私たちは値を用いて計算します。値はプログラムが受け渡したり操作したりする実体です。例えば、2つの数値の最小値を計算するために、下記のようなプログラムを書くでしょう。

```tut:book
2.min(3)
```

ここに2つの値 `2` と `3` があり、それらを `2` に評価されるより大きなプログラムに結合しています。

Scala において、すべての値は*オブジェクト*で、のちほど見ていくように特定の意味を持ちます。

さて次に型のことを考えましょう。型はプログラム上の制約で、どのようにオブジェクトを操作できるかを制限します。すでに2つの型 `String` と `Int` を、そして型によって異なる操作を実行できることを見てきました。

この段階で、型についてもっとも重要な点は*式は型を持つが値は持たない*ということです。私たちはコンピューターのメモリの任意の部分を検査できませんし、それを生成したプログラムを知らずして、どのようにそれが解釈されるのかを予言できません。例えば、Scala で `Int` 型と `Float` 型はどちらもメモリの32ビットによって表現されます。しかし、与えられた32ビットを `Int` や `Float` として解釈すべきというタグやその他の表示はないのです。

実行時エラーを引き起こす式の型を教えてと、Scala コンソールに尋ねることによって、コンパイル時に型が存在することを明らかにできます。

```scala
:type 2 / 0
// Int
```

```tut:book:fail
2 / 0
```

式 `2 / 0` は、それを評価したときには失敗するにも関わらず、`Int` 型を持つことを見ました。

コンパイル時に存在する型は、値に一貫した解釈を与えるプログラムを書くように制約します。特定の32ビットが、ある時は `Int` で、またある時は `Float` であると断言はできません。プログラムの型が検証されたとき、Scala はすべての値が一貫して使用されることを保証するので、値の表現で型の情報を記録する必要がありません。型の情報を取り除くこの処理を*型消去*[^type-erasure]と呼びます。

[^type-erasure]: これは完全に正しくはありません。Scala コードを実行するプログラムである Java 仮想マシンは2種類のオブジェクトを識別します。プリミティブ型は、値の表現と一緒にどんな型の情報も保持しません。オブジェクト型は型の情報を保持します。しかし、この型の情報は完全ではなく失われる場合もあります。それゆえに、コンパイル時と実行時の間にある区別を曖昧にすることは危険です。実行時にある型の情報を頼りにしない（本書ではそういうパターンを明らかにしていきます。）のであれば、それらの問題に遭遇することはないでしょう。

必然的に、型に合致する値について、考え得るすべての情報をその型は含みません。そうしないと、型検証はプログラムを実行することと等価になってしまいます。すでに見てきたように、型システムは `Int` をゼロで割ることを妨げることはなく、それは実行時エラーを引き起こします。

Scala コード設計の主要部分は、型システムの利用において、どのエラーケースを無視したいのかを決定することです。型システムでたくさんの便利な制約を表現することで、プログラムの信頼性を向上させられることを見ていきます。もしプログラムにおいて十分に重要であると決定すれば、エラーの可能性を表現する型システムを使用した除算演算子を実装することができます。型システムを上手に使用することは本書における重要なテーマのひとつです。


### 覚えておいてほしいこと

Scala を使用するのであれば、Scala プログラムのメンタルモデルを構築しなければなりません。このモデルにおける3つの基本的な構成要素は*式*・*型*・*値*です。

式は値に評価されるプログラムの部品です。Scala プログラムの主要な部品になります。

式は型を持ち、プログラムの制約を表現します。*コンパイル時*にプログラムの型は検証されます。型に一貫性がない場合、コンパイルは失敗し、プログラムを評価（実行）することはできません。

値はコンピューターのメモリに存在し、実行中のプログラムが操作するものです。Scala におけるすべての値は*オブジェクト*で、その意味はのちほど議論します。


### 練習問題

#### 型と値

Scala コンソールか Scala ワークシートを使用して、下記の式の型と値を特定してください。

```tut:book:silent
1 + 2
```

<div class="solution">
型は `Int` で値は `3` です。
</div>

```tut:book:silent
"3".toInt
```

<div class="solution">
型は `Int` で値は `3` です。
</div>

```tut:book:fail:silent
"foo".toInt
```

<div class="solution">
型は `Int` ですが、これは値に評価されません。その代わりに例外が発生し、発生した例外は値ではありません。これをどう理解すればいいでしょうか？式の結果による計算を続けられないということです。例えば、それを印字することはできません。

```tut:book
println("foo")
```

と

```tut:book:fail
println("foo".toInt)
```

を比較してみてください。後者でどんな印字も発生しないことは、`println` が評価されないということを示しています。
</div>
