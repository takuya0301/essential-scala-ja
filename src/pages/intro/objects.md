## オブジェクトとの相互作用


前節では Scala プログラムの基本的な構成要素である式・型・値を見てきました。また、**すべての値はオブジェクトである**ことも学びました。本節では、オブジェクトとオブジェクトに対してどのように相互作用するのかについて学んでいきます。

### オブジェクト

オブジェクトはデータとそのデータへの操作のグループです。例えば、`2` はオブジェクトです。データは整数の2で、データへの操作はなじみのある `+` や `-` などです。

オブジェクトのデータと操作について特別な専門用語があります。操作は**メソッド (method)** として知られています。データは**フィールド (field)** に保持されます。

### メソッド呼び出し

メソッド**呼び出し (call)** によってオブジェクトを作用させます[^patterns]。メソッド呼び出しの例をいくつかすでに見てきました。例えば、`String` の大文字版をその `toUpperCase` メソッドを呼び出すことによって取得できることを見ました。

```tut:book
"hello".toUpperCase
```

一部のメソッドは**引数 (parameter)** を受け取り、それはメソッドがどのように動作するかを制御します。例えば、`take` メソッドは `String` から文字を取り出します。いくつの文字を取り出したいかを指定する引数を `take` に渡す必要があります。

```tut:book
"abcdef".take(3)
"abcdef".take(2)
```

<div class="callout callout-info">
#### メソッド呼び出し文法 {-}

メソッド呼び出しのための文法は、

```scala
anExpression.methodName(param1, ...)
```

か

```scala
anExpression.methodName
```

である。ここで、

- `anExpression` はオブジェクトに評価される任意の式
- `methodName` はメソッドの名前
- `param1, ...` はメソッドの引数に評価される1つ以上の式

とする。
</div>

メソッド呼び出しは式なのでオブジェクトに評価されます。これは、より複雑なプログラムをつくるために、メソッド呼び出しを連鎖できるということを意味します。

```tut:book
"hello".toUpperCase.toLowerCase
```

メソッド呼び出しにおける様々な式はどの順番で評価されるのでしょうか？メソッド引数は、メソッドが呼び出される前に左から右に評価されます。下記の式では、

```tut:book
"Hello world!".take(2 + 3)
```

最初に式 `"Hello world!"` が、次に `2 + 3`（これは、最初に `2` を、次に `3` を評価する必要があります。）が、そして最後に `"Hello world!".take(5)` が評価されます。

### 演算子

Scala においてすべての値はオブジェクトであるため、`Int` や `Boolean` のようなプリミティブ型についてもメソッドを呼び出すことができます。これは `int` や `boolean` がオブジェクトではない Java と対照的です。

```tut:book
123.toShort // これは Scala で `Short` を定義する方法です
123.toByte // これは `Byte` を定義する方法です
```

しかし、`Int` がオブジェクトであれば、`+` や `-` のような基本的な算術演算子は何でしょうか？それらもまたメソッドでしょうか？そうです。Scala のメソッドは英数字の名前と同じようにシンボルの名前を持つことができます。

```tut:book
43 - 3 + 2
43.-(3).+(2)
```

（Scala 2.10 以前においては、`43.` を `Double` として解釈されることを防ぐために、`(43).-(3).+(2)` と書く必要があるので注意してください。）

<div class="callout callout-info">
#### 中置演算子記法 {-}

Scala において `a.b(c)` と書かれた任意の式は `a b c` と書ける。

`a b c d e` が等価であるのは `a.b(c).d(e)` で、`a.b(c, d, e)` ではないことに注意する。
</div>

シンボルの名前を持つか、英数字の名前を持つかにかかわらず、1つの引数を受け取るどんなメソッドでも**中置演算子記法 (infix operator notation)** を使用できます。

```tut:book:silent
"the quick brown fox" split " "
// res: Array[String] = Array(the, quick, brown, fox)
```

中置記法は、いくつかの文法的速記のひとつで、冗長なメソッド呼び出しの代わりに、簡潔な演算子式を書くことを可能にします。**前置 (prefix)**・**後置 (postfix)**・**右結合 (right-associative)**・**代入演算子 (assignment-style)** という記法もありますが、中置記法に比べると一般的ではありません。

中置演算子の結合は何の優先順位規則を支持すべきか？という質問はそれ自身をもたらします。Scala は、数学や論理の直観的知識にならい、メソッド名として使用する識別子から得られる [優先順位規則][link-precedence-rules] 一式を使用します。

```tut:book
2 * 3 + 4 * 5
(2 * 3) + (4 * 5)
2 * (3 + 4) * 5
```

### 覚えておいてほしいこと

Scala のすべての値はオブジェクトです。それらの**メソッド呼び出しによってオブジェクトを作用**させます。Java を背景知識としているのであれば、`Int` や他の任意のプリミティブ値のメソッドを呼び出せることに注意してください。

メソッド呼び出しのための文法は、

```scala
anExpression.methodName(parameter, ...)
```

か

```scala
anExpression methodName parameter
```

です。

**Scala は非常に少ない演算子を持ち、ほとんどすべてはメソッド呼び出しです**。中置演算子記法のような構文規則をコードを簡潔かつ読みやすくするために使用しますが、標準のメソッド記法の方がわかりやすい場合はいつでもそれに戻すことができます。

のちほど見ていくように、式を伴うプログラミングにおける Scala の焦点は、Java で実現するよりさらに短いコードで書くことを可能にすることです。また、値と型を使用する非常に直観的な方法で、コードについての判断を可能にします。

### 練習問題

#### 演算子スタイル

演算子スタイルに書き直してください。

```tut:book
"foo".take(1)
```

<div class="solution">
```tut:book
"foo" take 1
```
</div>

メソッド呼び出しスタイルに書き直してください。

```tut:book
1 + 2 + 3
```

<div class="solution">
```tut:book
1.+(2).+(3)
```
</div>

#### 置換

下記の2つの式の間にある違いは何ですか？類似点は何ですか？

```tut:book:silent
1 + 2 + 3

6
```

<div class="solution">
2つの式は同じ結果型と同じ返却値を持ちます。しかし、それらは異なった方法でその結果に辿り着きます。前者は一連の加算によってその結果を計算する一方、後者はただ単にリテラルです。

どちらの式も副作用を持たないので、ユーザー視点からそれらは交換可能です。`1 + 2 + 3` と書けるところはどこでも `6` と書け、どんなプログラムの意味も変えることはありません。逆もまた同様です。これは**置換 (substitution)**（訳注：数学だと**代入**という訳語が一般的です。）として知られており、あなたは数式を簡単にする原理として学校で記憶しているかもしれません。

プログラマーとしてはコードがどのように動くのかというメンタルモデルを養う必要があります。**評価の置換モデル**は目に入る式はどれでもその結果と置換して構わないというとりわけ単純なモデルです。副作用がないことで、式の置換モデルはいつでも機能します[^side-effects]。式の各構成要素である型と値を知っていれば、式全体としての型と値を知っています。関数型プログラミングにおいて副作用を避けようと努力している理由は、それがプログラムを容易に理解できるようにするからです。
</div>

[^side-effects]: 副作用とは正確には何でしょうか？ひとつの実用的な定義は、間違った結果を置換によって生じさせてしまう何かのことです。副作用がなければ、置換は**必ず**機能するのでしょうか？Scala の本当に正しいモデルを示すには、置換を適用する順番を定義する必要があります。いくつかの考えうる順番があります。（例えば、置換を左から右へ実行するのか、右から左へ実行するのか？置換をできるだけ早くするのか、値が必要になるまで遅延するのか？）ほとんどいつも置換の順番は問題になりませんが、それが問題になる場合もあります。Scala はいつも「左から右へ」「できるだけ早く」置換を適用します。

[^patterns]: パターンマッチングと呼ばれるオブジェクトを作用させる別の方法があります。パターンマッチングはのちほど紹介します。