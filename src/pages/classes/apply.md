## 関数としてのオブジェクト

前節、最後の演習で `Adder` と呼ばれるクラスを定義しました。

```tut:book:silent
class Adder(amount: Int) {
  def add(in: Int): Int = in + amount
}
```

議論の中で、計算を表現するオブジェクトとしての `Adder` を説明しました。それは、値として渡すことのできるメソッドを得られたようなものでした。

計算のように振る舞うオブジェクトは強力な概念で、Scala にはそれを生成するための言語機能が完全に備わっています。それらのオブジェクトは**関数 (function)** と呼ばれ、**関数型プログラミング (functional programming)** の基礎を成します。

### apply メソッド

ここでは、関数型プログラミングをサポートする Scala の一機能**関数適用文法 (function application syntax)** を見ていきましょう。

Scala では、慣例によって、`apply` と呼ばれるメソッドを持つオブジェクトを関数のように「呼び出す」ことができます。`apply` と名付けられたメソッドによって、呼び出し文法 `foo.apply(args)` が `foo(args)` になるという特別な略記法が与えられます。

例えば、`Adder` の `add` メソッドを `apply` に改名してみましょう。

```tut:book:silent
class Adder(amount: Int) {
  def apply(in: Int): Int = in + amount
}
```

```tut:book
val add3 = new Adder(3)
add3.apply(2)
add3(4) // add3.apply(4) の略記法
```

この簡単なトリックによって、オブジェクトは文法的に関数らしく「見える」ようになります。オブジェクトを、変数に代入したり、引数として受け渡したり、メソッドではできなかったことがたくさんできます。

<div class="callout callout-info">

#### 関数適用文法 {-}

メソッド呼び出し `object.apply(parameter, ...)` は `object(parameter, ...)` と書くこともできる。

</div>

### 覚えておいてほしいこと

本節では、オブジェクトを関数であるかのように「呼び出す」ための**関数適用文法**を見ました。

関数適用文法は、`apply` メソッドが定義されたどんなオブジェクトでも利用可能です。

関数適用文法によって、計算のように振る舞う第一級値（訳注：[第一級関数](https://ja.wikipedia.org/wiki/%E7%AC%AC%E4%B8%80%E7%B4%9A%E9%96%A2%E6%95%B0)）を持てるようになりました。メソッドと違って、オブジェクトはデータとして受け渡すことができます。これで、Scala における真の関数型プログラミングに一歩近付きました。

### 演習

#### 関数が関数でないのはどんなとき？

次節の最後に、いくつかのコードを書く機会があります。ここで、重要な理論上の疑問について考えてみましょう。

関数適用文法は、計算を実行する真に再利用可能なオブジェクトを生成できることに、どのくらい近付いているのでしょうか？何が足りないのでしょうか？

<div class="solution">
主に足りていないものは、値を横断的に抽象化する方法である**型**です。

現時点では、数値を加算するという知識を捕捉するために `Adder` と呼ばれるクラスを定義できますが、他の開発者はその知識を使用するために、この特定のクラスについて知っている必要があるため、そのコードはコードベースを横断して可搬であるとは言えません。

`Handler` や `Callback`、`Adder`、`BinaryAdder` などのような名前で共通する関数型のライブラリを定義できますが、これはすぐに非現実的になってしまいます。

後ほど、様々な状況で使用できる一般的な関数型一式を定義することで、Scala がこの問題にどのように対処しているのかを見ていきましょう。
</div>
